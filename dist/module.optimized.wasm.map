{"version":3,"sources":["src/assembly/shape.ts","src/assembly/pipe.ts","src/assembly/queue.ts","src/shared/keyboard.ts","src/assembly/tinyFont.ts","src/assembly/simpleRender.ts","src/assembly/game.ts","src/assembly/util.ts","src/assembly/imports.ts","~lib/array.ts","~lib/internal/arraybuffer.ts","~lib/internal/allocator.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["export const PIPE_OUTLET_NONE: u8 = 0;\nexport const PIPE_OUTLET_RIGHT: u8 = 1;\nexport const PIPE_OUTLET_LEFT: u8 = 1 << 1;\nexport const PIPE_OUTLET_BOTTOM: u8 = 1 << 2;\nexport const PIPE_OUTLET_TOP: u8 = 1 << 3;\nexport const PIPE_OUTLET_CROSS: u8 =\n  PIPE_OUTLET_BOTTOM | PIPE_OUTLET_LEFT | PIPE_OUTLET_RIGHT | PIPE_OUTLET_TOP;\n\nexport const PIPE_START: u8 = 1 << 4;\nexport const PIPE_END: u8 = 1 << 5;\nexport const PIPE_BLOCKED: u8 = 1 << 6;\n","import * as Shape from \"./shape\";\nimport { logi } from \"./imports\";\n\nexport const BURST_TIME: i32 = 1000 * 5;\n\ntype SHAPE = u8;\ntype DOUBLESHAPE = u8;\ntype FLOW_START_TIME = i32;\n\nconst SHAPE_OFFSET: usize = 0;\nconst FLOW1_TYPE_OFFSET: usize = SHAPE_OFFSET + sizeof<SHAPE>();\nconst FLOW2_TYPE_OFFSET: usize = FLOW1_TYPE_OFFSET + sizeof<DOUBLESHAPE>();\nconst FLOW1_START_TIME_OFFSET: usize = FLOW2_TYPE_OFFSET + sizeof<DOUBLESHAPE>();\nconst FLOW2_START_TIME_OFFSET: usize = FLOW1_START_TIME_OFFSET + sizeof<FLOW_START_TIME>();\nexport const SIZE: usize = FLOW2_START_TIME_OFFSET + sizeof<FLOW_START_TIME>();\n\nlet offsetPipeArray = HEAP_BASE;\n\nconst getStartOffset = (index: usize): usize => offsetPipeArray + index * SIZE;\n\nexport function getShape(index: usize): u8 {\n  return load<u8>(getStartOffset(index) + SHAPE_OFFSET);\n}\nexport function saveShape(index: usize, shape: u8): void {\n  let offset = getStartOffset(index);\n  store<u8>(offset + SHAPE_OFFSET, shape);\n  store<u8>(offset + FLOW1_TYPE_OFFSET, 0);\n  store<u8>(offset + FLOW2_TYPE_OFFSET, 0);\n  store<u8>(offset + FLOW1_START_TIME_OFFSET, 0);\n  store<u8>(offset + FLOW2_START_TIME_OFFSET, 0);\n}\n\nexport function getIndex(x: i32, y: i32, gridSizeX: i32): i32 {\n  return y * gridSizeX + x;\n}\n\nexport function getXFromIndex(index: i32, gridSizeX: i32): i32 {\n  return index % gridSizeX;\n}\n\nexport function getYFromIndex(index: i32, gridSizeY: i32): i32 {\n  return index / gridSizeY;\n}\n\nexport function getFlowFrom(index: usize, flowIndex: i32): u8 {\n  return load<u8>(getStartOffset(index) + FLOW1_TYPE_OFFSET + flowIndex * sizeof<DOUBLESHAPE>());\n}\n\nexport function startFlowFrom(index: usize, direction: u8, time: i32): void {\n  let flowIndex = getFlowFrom(index, 0) === 0 ? 0 : 1;\n  let offset = getStartOffset(index) + FLOW1_TYPE_OFFSET + flowIndex * sizeof<DOUBLESHAPE>();\n  store<u8>(offset, direction);\n\n  let flowStartOffset = getFlowStartOffset(index, direction);\n  store<i32>(flowStartOffset, time);\n}\n\nfunction getFlowStartOffset(index: usize, direction: u8): usize {\n  let startIndex = getStartOffset(index);\n  let flow1Type = load<u8>(startIndex + FLOW1_TYPE_OFFSET);\n  if (flow1Type & direction) return startIndex + FLOW1_START_TIME_OFFSET;\n  let flow2Type = load<u8>(startIndex + FLOW2_TYPE_OFFSET);\n  if (flow2Type & direction) return startIndex + FLOW2_START_TIME_OFFSET;\n  return 0;\n}\n\nexport function getFlowStart(index: i32, direction: u8): i32 {\n  let offset = getFlowStartOffset(index, direction);\n  return load<i32>(offset);\n}\n\nexport function getOutlet(shape: u8, flowFrom: u8): u8 {\n  if (shape & Shape.PIPE_START) {\n    return shape & 0b1111;\n  }\n\n  let onlyShape: i8 = (shape as u8) & 0b1111;\n  if (onlyShape === Shape.PIPE_OUTLET_CROSS) {\n    if (flowFrom === Shape.PIPE_OUTLET_TOP) return Shape.PIPE_OUTLET_BOTTOM;\n    if (flowFrom === Shape.PIPE_OUTLET_BOTTOM) return Shape.PIPE_OUTLET_TOP;\n    if (flowFrom === Shape.PIPE_OUTLET_LEFT) return Shape.PIPE_OUTLET_RIGHT;\n    return Shape.PIPE_OUTLET_LEFT;\n  } else {\n    return flowFrom ^ onlyShape;\n  }\n}\n\nfunction checkBurstSide(\n  flowTimeOffset: usize,\n  flowTypeOffset: usize,\n  index: usize,\n  time: i32,\n  flowMultiplier: i32\n): u8 {\n  let offset = getStartOffset(index) + flowTimeOffset;\n  let startTime = load<i32>(offset);\n  if (startTime > 0) {\n    if (startTime + BURST_TIME / flowMultiplier < time) {\n      store<i32>(offset, 0);\n      let flowFrom = <u8>load<u8>(getStartOffset(index) + flowTypeOffset);\n      let shape = getShape(index);\n      return getOutlet(shape, flowFrom);\n    }\n  }\n\n  return 0;\n}\n\nexport function checkBurst(index: usize, time: i32, flowMultiplier: i32): u8 {\n  return (\n    checkBurstSide(FLOW1_START_TIME_OFFSET, FLOW1_TYPE_OFFSET, index, time, flowMultiplier) |\n    checkBurstSide(FLOW2_START_TIME_OFFSET, FLOW2_TYPE_OFFSET, index, time, flowMultiplier)\n  );\n}\n\nexport function validPlacementLocation(index: usize): boolean {\n  let shape = getShape(index);\n  if (shape & Shape.PIPE_BLOCKED) return false;\n  if (shape & Shape.PIPE_START) return false;\n  if (shape & Shape.PIPE_END) return false;\n\n  let flow1 = getFlowFrom(index, 0);\n  if (flow1 > 0) return false;\n\n  let flow2 = getFlowFrom(index, 1);\n  if (flow2 > 0) return false;\n\n  return true;\n}\n","import { World } from \"./game\";\nimport * as Shape from \"./shape\";\nimport { randomInt } from \"./util\";\n\nexport const MAX: u8 = 5;\nconst SHAPE_OFFSET = 0;\nexport const SIZE: usize = MAX * sizeof<u8>();\n\nconst getStartOffset = (index: usize): usize => World.OFFSET_QUEUE_ARRAY + index * SIZE;\n\nexport function fill(): void {\n  for (let i: u8 = 0; i < MAX; i++) {\n    fillWithRandomShape(i);\n  }\n}\n\nfunction fillWithRandomShape(index: i32): void {\n  let option: u8 = randomInt(0, 6) as u8;\n  let shape: u8 = 0;\n\n  // prettier-ignore\n  switch (option) {\n    case 0: shape = Shape.PIPE_OUTLET_LEFT | Shape.PIPE_OUTLET_TOP; break;\n    case 1: shape = Shape.PIPE_OUTLET_RIGHT | Shape.PIPE_OUTLET_TOP; break;\n    case 2: shape = Shape.PIPE_OUTLET_LEFT | Shape.PIPE_OUTLET_BOTTOM; break;\n    case 3: shape = Shape.PIPE_OUTLET_RIGHT | Shape.PIPE_OUTLET_BOTTOM; break;\n    case 4: shape = Shape.PIPE_OUTLET_CROSS; break;\n    case 5: shape = Shape.PIPE_OUTLET_RIGHT | Shape.PIPE_OUTLET_LEFT; break;\n    case 6: shape = Shape.PIPE_OUTLET_TOP | Shape.PIPE_OUTLET_BOTTOM; break;\n  }\n\n  let randomAttribute: u8 = randomInt(0, 12) as u8;\n  switch (randomAttribute) {\n    case 0:\n      shape = shape | Shape.PIPE_BLOCKED;\n      break;\n  }\n\n  storeShape(index, shape);\n}\n\nexport function storeShape(index: i32, shape: u8): void {\n  store<u8>(getStartOffset(index) + SHAPE_OFFSET, shape);\n}\n\nexport function getShape(index: i32): u8 {\n  return load<u8>(getStartOffset(index) + SHAPE_OFFSET);\n}\n\nexport function pop(): u8 {\n  let shape = getShape(0);\n  for (let i = 1; i < (MAX as i32); i++) {\n    let oldShape = getShape(i);\n    storeShape(i - 1, oldShape);\n  }\n  fillWithRandomShape(MAX - 1);\n  return shape;\n}\n","export const FLAG_UP = 1 << 1;\nexport const FLAG_DOWN = 1 << 2;\nexport const FLAG_LEFT = 1 << 3;\nexport const FLAG_RIGHT = 1 << 4;\nexport const FLAG_SPACE = 1 << 5;\n","// Original Author: Paul Sauve (https://github.com/PaulBGD/PixelFont)\n// Adapted to AssemblyScript by Lee Bradley\nexport const LETTER_0: u16 = 0b0111101101101111;\nexport const LETTER_1: u16 = 0b0010010010010010;\nexport const LETTER_2: u16 = 0b0111001111100111;\nexport const LETTER_3: u16 = 0b0111100111100111;\nexport const LETTER_4: u16 = 0b0100100111101101;\nexport const LETTER_5: u16 = 0b0111100111001111;\nexport const LETTER_6: u16 = 0b0111101111001111;\nexport const LETTER_7: u16 = 0b0100100100100111;\nexport const LETTER_8: u16 = 0b0111101111101111;\nexport const LETTER_9: u16 = 0b0111100111101111;\nexport const LETTER_A: u16 = 0b0101111101101010;\nexport const LETTER_B: u16 = 0b0011101111101011;\nexport const LETTER_C: u16 = 0b0111001001001111;\nexport const LETTER_D: u16 = 0b0011101101101011;\nexport const LETTER_E: u16 = 0b0111001111001111;\nexport const LETTER_F: u16 = 0b0001001011001111;\nexport const LETTER_G: u16 = 0b0110001101001110;\nexport const LETTER_H: u16 = 0b0101101111101101;\nexport const LETTER_I: u16 = 0b0111010010010111;\nexport const LETTER_J: u16 = 0b0111101100100111;\nexport const LETTER_K: u16 = 0b0001101011101001;\nexport const LETTER_L: u16 = 0b0111001001001001;\nexport const LETTER_M: u16 = 0b0001001101101111;\nexport const LETTER_N: u16 = 0b0001001101011001;\nexport const LETTER_O: u16 = 0b0111101101101111;\nexport const LETTER_P: u16 = 0b0001001111101111;\nexport const LETTER_Q: u16 = 0b0111101001001110;\nexport const LETTER_R: u16 = 0b0101011101101011;\nexport const LETTER_S: u16 = 0b0111100111001111;\nexport const LETTER_T: u16 = 0b0010010010010111;\nexport const LETTER_U: u16 = 0b0111101101101101;\nexport const LETTER_V: u16 = 0b0100010010001001;\nexport const LETTER_W: u16 = 0b0111101001001001;\nexport const LETTER_X: u16 = 0b0001010100010001;\nexport const LETTER_Y: u16 = 0b0010010010101101;\nexport const LETTER_Z: u16 = 0b0111010100000111;\nexport const LETTER_SPACE: u16 = 0b0000000000000000;\n\nexport function getLetterFromChar(char: i32): i32 {\n  switch (char) {\n    case 48:\n      return LETTER_0;\n    case 49:\n      return LETTER_1;\n    case 50:\n      return LETTER_2;\n    case 51:\n      return LETTER_3;\n    case 52:\n      return LETTER_4;\n    case 53:\n      return LETTER_5;\n    case 54:\n      return LETTER_6;\n    case 55:\n      return LETTER_7;\n    case 56:\n      return LETTER_8;\n    case 57:\n      return LETTER_9;\n    case 65:\n      return LETTER_A;\n    case 66:\n      return LETTER_B;\n    case 67:\n      return LETTER_C;\n    case 68:\n      return LETTER_D;\n    case 69:\n      return LETTER_E;\n    case 70:\n      return LETTER_F;\n    case 71:\n      return LETTER_G;\n    case 72:\n      return LETTER_H;\n    case 73:\n      return LETTER_I;\n    case 74:\n      return LETTER_J;\n    case 75:\n      return LETTER_K;\n    case 76:\n      return LETTER_L;\n    case 77:\n      return LETTER_M;\n    case 78:\n      return LETTER_N;\n    case 79:\n      return LETTER_O;\n    case 80:\n      return LETTER_P;\n    case 81:\n      return LETTER_Q;\n    case 82:\n      return LETTER_R;\n    case 83:\n      return LETTER_S;\n    case 84:\n      return LETTER_T;\n    case 85:\n      return LETTER_U;\n    case 86:\n      return LETTER_V;\n    case 87:\n      return LETTER_W;\n    case 88:\n      return LETTER_X;\n    case 89:\n      return LETTER_Y;\n    case 90:\n      return LETTER_Z;\n    default:\n    case 32:\n      return LETTER_SPACE;\n  }\n}\n","import { World } from \"./game\";\nimport * as Shape from \"./shape\";\nimport * as Pipe from \"./pipe\";\nimport * as Queue from \"./queue\";\nimport { getTime, logi, logf } from \"./imports\";\nimport { getLetterFromChar } from \"./tinyFont\";\n\nconst PIPE_SIZE = 20;\nconst PIPE_RADIUS = 4;\nconst PIPE_ENDPOINT = 14;\n\nconst PIXEL_SIZE = sizeof<i32>();\n\nconst BUFFER_WIDTH = PIXEL_SIZE * PIPE_SIZE * 10;\nconst BUFFER_SIZE = BUFFER_WIDTH * PIPE_SIZE * 8;\nconst FLAG_CURSOR = 1;\nconst FLAG_INVALID = 1 << 1;\n\nfunction getPos(color: i32, pos: i32): f32 {\n  let offset = 24 - pos * 8;\n  return <f32>((color & (0xff << offset)) >>> offset);\n}\n\nfunction getPosColor(color: f32, alpha: f32, inv_alpha: f32, bg: i32, pos: i32): u8 {\n  let fg = alpha * getPos(<i32>color, pos);\n  let bga = inv_alpha * getPos(bg, pos);\n  // logf(fg);\n  return (fg + bga) as u8;\n}\n\nfunction renderPixel(offset: i32, color: i32, alpha: boolean = false): void {\n  if (alpha) {\n    if ((color & 0xff000000) === 0xff000000) {\n      store<i32>(offset, color);\n    } else {\n      let bg: i32 = load<i32>(offset);\n\n      let fg3 = getPos(color, 0);\n\n      if (fg3 === 0) return;\n\n      let alpha: f32 = fg3 / 255;\n      let inv_alpha: f32 = (255 - fg3) / 255;\n\n      let b: u8 = getPosColor(<f32>color, alpha, inv_alpha, bg, 1);\n      let g: u8 = getPosColor(<f32>color, alpha, inv_alpha, bg, 2);\n      let r: u8 = getPosColor(<f32>color, alpha, inv_alpha, bg, 3);\n\n      let result: i32 = 0xff000000 + ((<i32>b) << 16) + ((<i32>g) << 8) + r;\n\n      store<i32>(offset, result);\n    }\n  } else {\n    store<i32>(offset, color);\n  }\n}\n\nconst OFFSET_GRID_X = PIPE_SIZE + 3;\nconst OFFSET_GRID_Y = 4;\n\nfunction getPixelOffset(x: i32, y: i32, width: i32): i32 {\n  return (x + y * width) * PIXEL_SIZE;\n}\n\nconst COLOR_START = 0xff57c35e; // 5ec357; // 0xff00ff00;\nconst COLOR_END = 0xff5757c3; //c35757; // 0xff0000ff;\n\nconst PIPE_COLOR = 0xff0f84bf; //bf840f; // 0xff808080;\nconst PIPE_INSIDE_COLOR = 0xff3d4e57;\nconst BACKGROUND_COLOR = 0x00000000; // 0xff4b4b4d; // 4d4b4b; // 0xff000000;\n\nconst PIPE_CONTENTS_COLOR = 0xff00f7ff; // fff700\n\nconst PIPE_BLOCKED_BORDER = 0xffa3b0b0;\nconst PIPE_BLOCKED_BACKGROUND = 0xff787878;\n\nfunction renderPipe(offset: i32, width: i32, pipeShape: i32, flags: i32 = 0): void {\n  let onlyShape: i8 = (pipeShape as u8) & 0b1111;\n\n  let insideColor: i32 = PIPE_INSIDE_COLOR;\n  let pipeColor: i32 = PIPE_COLOR;\n  let blockedBg: i32 = PIPE_BLOCKED_BACKGROUND;\n  let blockedBorder: i32 = PIPE_BLOCKED_BORDER;\n\n  if (flags & FLAG_CURSOR) {\n    insideColor = flags & FLAG_INVALID ? 0xff3d3d57 : 0xff574f3d;\n    pipeColor = flags & FLAG_INVALID ? 0xff2d2d80 : 0xff805f2d;\n    blockedBg = insideColor;\n    blockedBorder = pipeColor;\n  }\n\n  if (pipeShape & Shape.PIPE_BLOCKED) {\n    drawRectOffset(width, offset, PIPE_SIZE, PIPE_SIZE, blockedBorder);\n\n    drawRectOffset(\n      width,\n      offset + getPixelOffset(1, 1, width),\n      PIPE_SIZE - 2,\n      PIPE_SIZE - 2,\n      blockedBg\n    );\n  }\n\n  if (onlyShape & Shape.PIPE_OUTLET_TOP) {\n    drawRectOffset(\n      width,\n      offset + getPixelOffset(6, 0, width),\n      PIPE_RADIUS * 2,\n      PIPE_ENDPOINT,\n      pipeColor\n    );\n  }\n\n  if (onlyShape & Shape.PIPE_OUTLET_BOTTOM) {\n    drawRectOffset(\n      width,\n      offset + getPixelOffset(6, 6, width),\n      PIPE_RADIUS * 2,\n      PIPE_ENDPOINT,\n      pipeColor\n    );\n  }\n\n  if (onlyShape & Shape.PIPE_OUTLET_LEFT) {\n    drawRectOffset(\n      width,\n      offset + getPixelOffset(0, 6, width),\n      PIPE_ENDPOINT,\n      PIPE_RADIUS * 2,\n      pipeColor\n    );\n  }\n\n  if (onlyShape & Shape.PIPE_OUTLET_RIGHT) {\n    drawRectOffset(\n      width,\n      offset + getPixelOffset(6, 6, width),\n      PIPE_ENDPOINT,\n      PIPE_RADIUS * 2,\n      pipeColor\n    );\n  }\n\n  //\n  if (onlyShape & Shape.PIPE_OUTLET_TOP) {\n    drawRectOffset(width, offset + getPixelOffset(7, 0, width), 6, PIPE_ENDPOINT - 1, insideColor);\n  }\n\n  if (onlyShape & Shape.PIPE_OUTLET_BOTTOM) {\n    drawRectOffset(width, offset + getPixelOffset(7, 7, width), 6, PIPE_ENDPOINT - 1, insideColor);\n  }\n\n  if (onlyShape & Shape.PIPE_OUTLET_LEFT) {\n    drawRectOffset(width, offset + getPixelOffset(0, 7, width), PIPE_ENDPOINT - 1, 6, insideColor);\n  }\n\n  if (onlyShape & Shape.PIPE_OUTLET_RIGHT) {\n    drawRectOffset(width, offset + getPixelOffset(7, 7, width), PIPE_ENDPOINT - 1, 6, insideColor);\n  }\n\n  if (pipeShape & (Shape.PIPE_START | Shape.PIPE_END)) {\n    let color = pipeShape & Shape.PIPE_START ? COLOR_START : COLOR_END;\n    drawRectOffset(width, offset + getPixelOffset(8, 8, width), 4, 4, color);\n  }\n}\n\nfunction drawRect(\n  width: i32,\n  offsetX: i32,\n  offsetY: i32,\n  sizeX: i32,\n  sizeY: i32,\n  color: i32\n): void {\n  let offset = getCanvasOffset() + getPixelOffset(offsetX, offsetY, width);\n  drawRectOffset(width, offset, sizeX, sizeY, color);\n}\n\nfunction clipRectAlpha(\n  bufferX: i32,\n  bufferY: i32,\n  width: i32,\n  height: i32,\n  canvasX: i32,\n  canvasY: i32,\n  sizeX: i32,\n  alpha: u8\n): void {\n  let baseBufferOffset = getBufferOffset() + getPixelOffset(bufferX, bufferY, BUFFER_WIDTH);\n  let baseCanvasOffset = getCanvasOffset() + getPixelOffset(canvasX, canvasY, sizeX);\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      let color = load<i32>(baseBufferOffset + getPixelOffset(x, y, BUFFER_WIDTH));\n      renderPixel(\n        baseCanvasOffset + getPixelOffset(x, y, sizeX),\n        color === 0x00000000 ? color : (color & 0x00ffffff) | (alpha << 24),\n        true\n      );\n    }\n  }\n}\n\nfunction clipRect(\n  bufferX: i32,\n  bufferY: i32,\n  width: i32,\n  height: i32,\n  canvasX: i32,\n  canvasY: i32,\n  sizeX: i32\n): void {\n  let baseBufferOffset = getBufferOffset() + getPixelOffset(bufferX, bufferY, BUFFER_WIDTH);\n  let baseCanvasOffset = getCanvasOffset() + getPixelOffset(canvasX, canvasY, sizeX);\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      let color = load<i32>(baseBufferOffset + getPixelOffset(x, y, BUFFER_WIDTH));\n      if (color !== 0x00000000) {\n        renderPixel(baseCanvasOffset + getPixelOffset(x, y, sizeX), color);\n      }\n    }\n  }\n}\n\nfunction drawRectOffset(width: i32, offset: i32, sizeX: i32, sizeY: i32, color: i32): void {\n  let incY = sizeY > 0 ? 1 : -1;\n  let incX = sizeX > 0 ? 1 : -1;\n  for (let y = 0; y !== sizeY; y += incY) {\n    for (let x = 0; x !== sizeX; x += incX) {\n      renderPixel(offset + getPixelOffset(x, y, width), color);\n    }\n  }\n}\n\nexport function render(width: i32, height: i32, time: i32): void {\n  let sizeX = World.gridSizeX;\n  let sizeY = World.gridSizeY;\n\n  drawRect(width, 0, 0, width, height, BACKGROUND_COLOR);\n\n  for (let x = 0; x < sizeX; x++) {\n    for (let y = 0; y < sizeY; y++) {\n      let index = Pipe.getIndex(x, y, World.gridSizeX);\n      let pipeShape = Pipe.getShape(index);\n\n      renderPipe(\n        getCanvasOffset() +\n          getPixelOffset(x * PIPE_SIZE + OFFSET_GRID_X, y * PIPE_SIZE + OFFSET_GRID_Y, width),\n        width,\n        pipeShape\n      );\n\n      for (let flowIndex = 0; flowIndex < 2; flowIndex++) {\n        let flowFrom = Pipe.getFlowFrom(index, flowIndex);\n        if (flowFrom > 0) {\n          let flowStart = Pipe.getFlowStart(index, flowFrom);\n          if (flowStart < time) {\n            let percentage: f32 =\n              (<f32>time - <f32>flowStart) / <f32>(Pipe.BURST_TIME / World.flowMultiplier);\n            if (percentage > 1) percentage = 1;\n            let pixelWidth: i32 = <i32>(percentage * <f32>PIPE_SIZE);\n\n            if ((pipeShape & Shape.PIPE_START) === 0) {\n              let startX = 0;\n              let startY = 0;\n              let flowHeight = 6;\n              let flowWidth = 6;\n              switch (flowFrom) {\n                case Shape.PIPE_OUTLET_TOP:\n                  startX = 7;\n                  flowHeight = pixelWidth > 13 ? 13 : pixelWidth;\n                  break;\n                case Shape.PIPE_OUTLET_BOTTOM:\n                  startX = 7;\n                  startY = PIPE_SIZE - 1;\n                  flowHeight = pixelWidth > 13 ? -13 : -pixelWidth;\n                  break;\n                case Shape.PIPE_OUTLET_LEFT:\n                  startY = 7;\n                  flowWidth = pixelWidth > 13 ? 13 : pixelWidth;\n                  break;\n                case Shape.PIPE_OUTLET_RIGHT:\n                  startY = 7;\n                  startX = PIPE_SIZE - 1;\n                  flowWidth = pixelWidth > 13 ? -13 : -pixelWidth;\n                  break;\n              }\n              drawRect(\n                width,\n                x * PIPE_SIZE + startX + OFFSET_GRID_X,\n                y * PIPE_SIZE + startY + OFFSET_GRID_Y,\n                flowWidth,\n                flowHeight,\n                PIPE_CONTENTS_COLOR\n              );\n            }\n\n            if (pixelWidth > 6) {\n              let remaining = pixelWidth - 7;\n              let startX = 7;\n              let startY = 7;\n              let flowHeight = 6;\n              let flowWidth = 6;\n              let outlet: u8 = Pipe.getOutlet(pipeShape, flowFrom);\n              switch (outlet) {\n                case Shape.PIPE_OUTLET_TOP:\n                  startY = 12;\n                  flowHeight = -remaining;\n                  break;\n                case Shape.PIPE_OUTLET_BOTTOM:\n                  flowHeight = remaining;\n                  break;\n                case Shape.PIPE_OUTLET_LEFT:\n                  startX = 12;\n                  flowWidth = -remaining;\n                  break;\n                case Shape.PIPE_OUTLET_RIGHT:\n                  flowWidth = remaining;\n                  break;\n              }\n\n              if (outlet) {\n                drawRect(\n                  width,\n                  x * PIPE_SIZE + startX + OFFSET_GRID_X,\n                  y * PIPE_SIZE + startY + OFFSET_GRID_Y,\n                  flowWidth,\n                  flowHeight,\n                  PIPE_CONTENTS_COLOR\n                );\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  drawQueue(width);\n  drawCursor(width, height, time);\n  drawProgressBar(width, height, time);\n\n  if (World.gameOver) {\n    drawGameOver(width, height);\n  }\n\n  if (World.isWinning) {\n    drawWin(width, height);\n  }\n}\n\nfunction drawCursor(width: i32, height: i32, time: i32): void {\n  let index = Pipe.getIndex(World.cursorPositionX, World.cursorPositionY, World.gridSizeX);\n  let validPlacement = Pipe.validPlacementLocation(index);\n  let startX = World.cursorPositionX * PIPE_SIZE;\n  let startY = World.cursorPositionY * PIPE_SIZE;\n\n  let shape = Queue.getShape(0);\n  drawRectOffset(BUFFER_WIDTH, getBufferOffset(), PIPE_SIZE, PIPE_SIZE, BACKGROUND_COLOR);\n  renderPipe(\n    getBufferOffset(),\n    //getCanvasOffset() +\n    //  getPixelOffset(startX + OFFSET_GRID_X - 2, startY + OFFSET_GRID_Y - 2, width),\n    BUFFER_WIDTH,\n    shape,\n    FLAG_CURSOR | (validPlacement ? 0 : FLAG_INVALID)\n  );\n  clipRectAlpha(\n    0,\n    0,\n    PIPE_SIZE,\n    PIPE_SIZE,\n    startX + OFFSET_GRID_X - 2,\n    startY + OFFSET_GRID_Y - 2,\n    width,\n    200\n  );\n  /*\n  renderPipe(\n    getCanvasOffset() +\n      getPixelOffset(startX + OFFSET_GRID_X - 2, startY + OFFSET_GRID_Y - 2, width),\n    width,\n    shape\n  );\n  */\n\n  /*\n  let color = validPlacement ? 0xffff00ff : 0xff0000ff;\n  let end = PIPE_SIZE - 1;\n  drawRect(width, startX + OFFSET_GRID_X, startY + OFFSET_GRID_Y, 1, 1, color);\n  drawRect(width, startX + OFFSET_GRID_X + end, startY + OFFSET_GRID_Y, 1, 1, color);\n  drawRect(width, startX + OFFSET_GRID_X, startY + end + OFFSET_GRID_Y, 1, 1, color);\n  drawRect(width, startX + OFFSET_GRID_X + end, startY + end + OFFSET_GRID_Y, 1, 1, color);\n  */\n}\n\nconst BORDER_COLOR = 0xff26323a;\nfunction drawQueue(width: i32): void {\n  drawRect(width, 0, 3, PIPE_SIZE + 2, PIPE_SIZE * Queue.MAX + 2, BORDER_COLOR);\n  drawRect(width, 1, 4, PIPE_SIZE, PIPE_SIZE * Queue.MAX, BACKGROUND_COLOR);\n  for (let i: u8 = 0; i < Queue.MAX; i++) {\n    let shape = Queue.getShape(i);\n    renderPipe(\n      getCanvasOffset() + getPixelOffset(1, (Queue.MAX - i - 1) * PIPE_SIZE + 4, width),\n      width,\n      shape\n    );\n  }\n\n  let queueLabel: Array<i32> = [81, 85, 69, 85, 69]; // QUEUE\n  for (let i = 0; i < queueLabel.length; i++) {\n    drawChar(queueLabel[i], width, 2 + i * 4, PIPE_SIZE * Queue.MAX + 7, BORDER_COLOR);\n  }\n}\n\nconst PROGRESSBAR_COLOR_GOOD = 0xff00ff00;\nconst PROGRESSBAR_COLOR_GAME_OVER = 0xff0000ff;\nconst PROGRESSBAR_HEIGHT = 10;\nfunction drawProgressBar(width: i32, height: i32, time: i32): void {\n  let fullProgressWidth: i32 = width;\n  let y = height - PROGRESSBAR_HEIGHT;\n  let x = 0;\n\n  if (World.countdownEnd > time) {\n    let percentage: f32 =\n      <f32>1 - (<f32>World.countdownEnd - <f32>time) / <f32>World.countdownTotal;\n    let pixelWidth: i32 = <i32>(percentage * <f32>fullProgressWidth);\n    drawRect(width, x, y, fullProgressWidth, PROGRESSBAR_HEIGHT, 0xff000000);\n    drawRect(width, x, y, pixelWidth, PROGRESSBAR_HEIGHT, PROGRESSBAR_COLOR_GOOD);\n  } else {\n    drawRect(\n      width,\n      x,\n      y,\n      fullProgressWidth,\n      PROGRESSBAR_HEIGHT,\n      World.gameOver ? PROGRESSBAR_COLOR_GAME_OVER : PROGRESSBAR_COLOR_GOOD\n    );\n  }\n}\n\nexport function drawChar(char: i32, width: i32, offsetX: i32, offsetY: i32, color: i32): void {\n  let letter = getLetterFromChar(char);\n  let shift: i16 = 0;\n\n  // 3x5\n  let baseOffset = getCanvasOffset() + getPixelOffset(offsetX, offsetY, width);\n  for (let y = 0; y < 5; y++) {\n    for (let x = 0; x < 3; x++) {\n      let on = letter & (1 << shift);\n      if (on) {\n        let offset = baseOffset + getPixelOffset(x, y, width);\n        renderPixel(offset, color);\n      }\n      shift++;\n    }\n  }\n}\n\nfunction getBufferOffset(): i32 {\n  return World.OFFSET_RENDERER;\n}\n\nexport function getCanvasOffset(): i32 {\n  return World.OFFSET_RENDERER + BUFFER_SIZE;\n}\n\nfunction drawGameOver(width: i32, height: i32): void {\n  let textHeight = 9;\n  let queueLabel: Array<i32> = [71, 65, 77, 69, 32, 79, 86, 69, 82];\n  let textWidth = queueLabel.length * 4 + 4;\n  let startX = (width - textWidth) / 2;\n  let startY = (height - textHeight) / 2;\n  drawRect(width, startX, startY, textWidth, textHeight, PIPE_INSIDE_COLOR);\n  drawRect(width, startX + 1, startY + 1, textWidth - 2, textHeight - 2, BACKGROUND_COLOR);\n  // drawRect(width, (width - textWidth + 1) / 2, (height - charHeight - 4) / 2, BACKGROUND_COLOR);\n  for (let i = 0; i < queueLabel.length; i++) {\n    drawChar(queueLabel[i], width, startX + 2 + i * 4, startY + 2, BORDER_COLOR);\n  }\n}\n\nfunction drawWin(width: i32, height: i32): void {\n  let textHeight = 9;\n  let queueLabel: Array<i32> = [89, 79, 85, 32, 87, 73, 78];\n  let textWidth = queueLabel.length * 4 + 4;\n  let startX = (width - textWidth) / 2;\n  let startY = (height - textHeight) / 2;\n  drawRect(width, startX, startY, textWidth, textHeight, PIPE_INSIDE_COLOR);\n  drawRect(width, startX + 1, startY + 1, textWidth - 2, textHeight - 2, BACKGROUND_COLOR);\n  // drawRect(width, (width - textWidth + 1) / 2, (height - charHeight - 4) / 2, BACKGROUND_COLOR);\n  for (let i = 0; i < queueLabel.length; i++) {\n    drawChar(queueLabel[i], width, startX + 2 + i * 4, startY + 2, BORDER_COLOR);\n  }\n}\n","import { randomInt, getRandomSetBit, getRandomSide } from \"./util\";\nimport * as Pipe from \"./pipe\";\nimport * as Shape from \"./shape\";\nimport * as Queue from \"./queue\";\nimport * as Keys from \"../shared/keyboard\";\nimport { getTime, logi } from \"./imports\";\nimport { render, getCanvasOffset } from \"./simpleRender\";\n\nexport type Time = i32;\n\nconst RESTART_GAME_AFTER = 1000 * 3;\n\n@unmanaged\nexport class World {\n  static gridSizeX: i32 = 0;\n  static gridSizeY: i32 = 0;\n\n  static cursorPositionX: i32 = 0;\n  static cursorPositionY: i32 = 0;\n\n  static lastUpdatedTime: i32 = 0;\n\n  static countdownEnd: i32;\n  static readonly countdownTotal: i32 = 1000 * 15;\n  static gameOver: boolean = false;\n  static gameResetTimeout: i32 = 0;\n\n  static flowMultiplier: i32 = 1;\n  static isWinning: bool = false;\n\n  static OFFSET_PIPE_ARRAY: usize = HEAP_BASE;\n  static OFFSET_QUEUE_ARRAY: usize;\n  static OFFSET_RENDERER: usize;\n}\n\nexport function setupWorld(sizeX: i32, sizeY: i32): void {\n  World.gridSizeX = sizeX;\n  World.gridSizeY = sizeY;\n\n  World.gameOver = false;\n  World.gameResetTimeout = 0;\n  World.flowMultiplier = 1;\n  World.isWinning = false;\n\n  // Setup array offset\n  World.OFFSET_QUEUE_ARRAY =\n    World.OFFSET_PIPE_ARRAY + World.gridSizeX * World.gridSizeY * Pipe.SIZE;\n  let endQueue = World.OFFSET_QUEUE_ARRAY + Queue.MAX * Queue.SIZE;\n\n  // Javascript's Uint32Array requires the canvas offset to be a multiple of 4\n  World.OFFSET_RENDERER = endQueue + (4 - (endQueue % 4));\n\n  Queue.fill();\n\n  for (let i = 0; i < sizeX * sizeY; i++) {\n    Pipe.saveShape(i, Shape.PIPE_OUTLET_NONE);\n  }\n\n  let maxX = sizeX - 1;\n  let maxY = sizeY - 1;\n\n  World.countdownEnd = getTime() + World.countdownTotal;\n\n  let sideIndex = getRandomSide(sizeX, sizeY);\n  let startX = sideIndex % sizeX;\n  let startY = (sideIndex - startX) / sizeX;\n  let startOptions = getValidOutlets(startX, startY, maxX, maxY);\n  let startDirection = getRandomSetBit(startOptions);\n  Pipe.saveShape(sideIndex, startDirection | Shape.PIPE_START);\n  Pipe.startFlowFrom(\n    Pipe.getIndex(startX, startY, sizeX),\n    Shape.PIPE_OUTLET_LEFT,\n    World.countdownEnd\n  );\n\n  let endX = maxX - startX;\n  let endY = maxY - startY;\n  let endOptions = getValidOutlets(endX, endY, maxX, maxY);\n  let endDirection = getRandomSetBit(endOptions);\n  Pipe.saveShape(endX + endY * sizeX, endDirection | Shape.PIPE_END);\n\n  /*\n  Pipe.saveShape(Pipe.getIndex(2, 1, sizeX), Shape.PIPE_OUTLET_TOP);\n  Pipe.saveShape(Pipe.getIndex(2, 2, sizeX), Shape.PIPE_OUTLET_BOTTOM);\n  Pipe.saveShape(Pipe.getIndex(2, 3, sizeX), Shape.PIPE_OUTLET_LEFT);\n  Pipe.saveShape(Pipe.getIndex(2, 4, sizeX), Shape.PIPE_OUTLET_RIGHT);\n  Pipe.saveShape(Pipe.getIndex(2, 5, sizeX), Shape.PIPE_OUTLET_TOP | Shape.PIPE_OUTLET_BOTTOM);\n  Pipe.saveShape(Pipe.getIndex(2, 6, sizeX), Shape.PIPE_OUTLET_CROSS);\n  */\n\n  /*\n  Pipe.saveShape(Pipe.getIndex(2, 2, sizeX), Shape.PIPE_OUTLET_RIGHT | Shape.PIPE_END);\n  Pipe.saveShape(Pipe.getIndex(3, 2, sizeX), Shape.PIPE_OUTLET_LEFT | Shape.PIPE_OUTLET_BOTTOM);\n  Pipe.saveShape(\n    Pipe.getIndex(3, 3, sizeX),\n    Shape.PIPE_OUTLET_LEFT | Shape.PIPE_OUTLET_TOP | Shape.PIPE_BLOCKED\n  );\n  Pipe.startFlowFrom(Pipe.getIndex(2, 2, sizeX), Shape.PIPE_OUTLET_LEFT, World.countdownEnd);\n  */\n\n  /*\n  Pipe.saveShape(Pipe.getIndex(2, 2, sizeX), Shape.PIPE_OUTLET_RIGHT | Shape.PIPE_END);\n  // Pipe.saveShape(Pipe.getIndex(3, 2, sizeX), Shape.PIPE_OUTLET_CROSS | Shape.PIPE_BLOCKED);\n  Pipe.saveShape(Pipe.getIndex(4, 2, sizeX), Shape.PIPE_START | Shape.PIPE_OUTLET_LEFT);\n  Pipe.startFlowFrom(Pipe.getIndex(4, 2, sizeX), Shape.PIPE_OUTLET_RIGHT, World.countdownEnd);\n  */\n\n  // Testing\n  /*\n  Pipe.saveShape(sizeX + 0, Shape.PIPE_OUTLET_LEFT | Shape.PIPE_OUTLET_RIGHT);\n  Pipe.startFlowFrom(sizeX + 0, Shape.PIPE_OUTLET_LEFT, World.countdownEnd);\n  Pipe.saveShape(sizeX + 1, Shape.PIPE_OUTLET_CROSS);\n  Pipe.saveShape(sizeX + 2, Shape.PIPE_OUTLET_LEFT | Shape.PIPE_OUTLET_BOTTOM);\n  Pipe.saveShape(sizeX + sizeX + 2, Shape.PIPE_OUTLET_LEFT | Shape.PIPE_OUTLET_TOP);\n  Pipe.saveShape(sizeX + sizeX + 1, Shape.PIPE_OUTLET_RIGHT | Shape.PIPE_OUTLET_TOP);\n  Pipe.saveShape(1, Shape.PIPE_OUTLET_RIGHT | Shape.PIPE_OUTLET_BOTTOM);\n  */\n}\n\nexport function updateTime(time: i32): void {\n  World.lastUpdatedTime = time;\n}\n\nexport function getValidOutlets(startX: i32, startY: i32, maxX: i32, maxY: i32): u8 {\n  let options: u8 = 0b1111; // TBLR\n  options &= startX === 0 ? 0b1101 : startX === maxX ? 0b1110 : 0b1111;\n  options &= startY === 0 ? 0b0111 : startY === maxY ? 0b1011 : 0b1111;\n  return options;\n}\n\nexport function getSizeX(): i32 {\n  return World.gridSizeX;\n}\n\nexport function getSizeY(): i32 {\n  return World.gridSizeY;\n}\n\nexport function getHeapBase(): usize {\n  return HEAP_BASE;\n}\n\nexport function setKeys(char: i8): void {\n  let y = World.cursorPositionY + (char & Keys.FLAG_DOWN ? 1 : char & Keys.FLAG_UP ? -1 : 0);\n  let x = World.cursorPositionX + (char & Keys.FLAG_RIGHT ? 1 : char & Keys.FLAG_LEFT ? -1 : 0);\n\n  if (!outOfBounds(x, y)) {\n    World.cursorPositionX = x;\n    World.cursorPositionY = y;\n  }\n\n  if (char & Keys.FLAG_SPACE) {\n    if (!World.isWinning) {\n      let index = World.cursorPositionX + World.cursorPositionY * World.gridSizeX;\n      if (Pipe.validPlacementLocation(index)) {\n        let newShape = Queue.pop();\n        Pipe.saveShape(index, newShape);\n\n        let winningMove = areAllStartFlowsConnectedToEndFlows();\n        if (winningMove) {\n          World.flowMultiplier = 8;\n          World.isWinning = true;\n        }\n      }\n    }\n  }\n}\n\nfunction areAllStartFlowsConnectedToEndFlows(): bool {\n  for (let x = 0; x < World.gridSizeX; x++) {\n    for (let y = 0; y < World.gridSizeY; y++) {\n      let index = Pipe.getIndex(x, y, World.gridSizeX);\n      let shape = Pipe.getShape(index);\n      if (shape & Shape.PIPE_START) {\n        if (!flowConnected(index, shape)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction flowConnected(index: i32, flowFrom: u8): bool {\n  let x = Pipe.getXFromIndex(index, World.gridSizeX);\n  let y = Pipe.getYFromIndex(index, World.gridSizeX);\n\n  let shape = Pipe.getShape(index);\n\n  let outlet = Pipe.getOutlet(shape, flowFrom);\n  let burstY = getBurstY(outlet, y);\n  let burstX = getBurstX(outlet, x);\n  if (!outOfBounds(burstX, burstY)) {\n    let burstIndex = Pipe.getIndex(burstX, burstY, World.gridSizeX);\n    let outletShape = Pipe.getShape(burstIndex);\n    let inlet = getInletFromOutlet(outlet);\n    if (outletShape > 0 && (inlet & outletShape) > 0) {\n      if (outletShape & Shape.PIPE_END) {\n        return true;\n      }\n\n      return flowConnected(burstIndex, inlet);\n    }\n  }\n\n  return false;\n}\n\nexport function getOffsetRenderer(): i32 {\n  return getCanvasOffset();\n}\n\nfunction showGameOver(time: i32): void {\n  World.gameOver = true;\n  World.gameResetTimeout = time + RESTART_GAME_AFTER;\n}\n\nfunction outOfBounds(x: i32, y: i32): bool {\n  if (x < 0) return true;\n  if (y < 0) return true;\n  if (x > World.gridSizeX - 1) return true;\n  if (y > World.gridSizeY - 1) return true;\n  return false;\n}\n\nfunction getInletFromOutlet(outlet: u8): u8 {\n  switch (outlet) {\n    case Shape.PIPE_OUTLET_BOTTOM:\n      return Shape.PIPE_OUTLET_TOP;\n    case Shape.PIPE_OUTLET_TOP:\n      return Shape.PIPE_OUTLET_BOTTOM;\n    case Shape.PIPE_OUTLET_LEFT:\n      return Shape.PIPE_OUTLET_RIGHT;\n    default:\n    case Shape.PIPE_OUTLET_RIGHT:\n      return Shape.PIPE_OUTLET_LEFT;\n  }\n}\n\nexport function step(width: i32, height: i32, time: i32): void {\n  /*\n  if (time > World.countdownEnd) {\n    for (let x = 0; x < World.gridSizeX; x++) {\n      for (let y = 0; y < World.gridSizeY; y++) {\n        let index = Pipe.getIndex(x, y, World.gridSizeX);\n        let shape = Pipe.getShape(index);\n        let inlet = getInletFromOutlet(burst);\n        if (shape & Shape.PIPE_START) {\n          Pipe.startFlowFrom(index, Shape.PIPE_OUTLET_LEFT, );\n        }\n      }\n    }\n  }\n  */\n\n  for (let x = 0; x < World.gridSizeX; x++) {\n    for (let y = 0; y < World.gridSizeY; y++) {\n      let index = Pipe.getIndex(x, y, World.gridSizeX);\n      let burst: u8 = Pipe.checkBurst(index, time, World.flowMultiplier);\n      if (burst > 0) {\n        let burstY = getBurstY(burst, y);\n        let burstX = getBurstX(burst, x);\n\n        if (outOfBounds(burstX, burstY)) {\n          showGameOver(time);\n        } else {\n          let index = Pipe.getIndex(burstX, burstY, World.gridSizeX);\n          let shape = Pipe.getShape(index);\n          let inlet = getInletFromOutlet(burst);\n          if (shape > 0 && (inlet & shape) > 0) {\n            Pipe.startFlowFrom(index, inlet, time);\n\n            if (shape & Shape.PIPE_END) {\n              World.gameResetTimeout = time + RESTART_GAME_AFTER;\n            }\n          } else {\n            showGameOver(time);\n          }\n        }\n      }\n    }\n  }\n\n  if (World.gameResetTimeout > 0 && World.gameResetTimeout <= time) {\n    setupWorld(World.gridSizeX, World.gridSizeY);\n  }\n\n  render(width, height, time);\n}\n\nfunction getBurstX(burst: u8, x: i32): i32 {\n  return x + (burst & Shape.PIPE_OUTLET_LEFT ? -1 : burst & Shape.PIPE_OUTLET_RIGHT ? 1 : 0);\n}\n\nfunction getBurstY(burst: u8, y: i32): i32 {\n  return y + (burst & Shape.PIPE_OUTLET_TOP ? -1 : burst & Shape.PIPE_OUTLET_BOTTOM ? 1 : 0);\n}\n","export function randomInt(min: i32, max: i32): i32 {\n  return (Math.floor(Math.random() * ((max - min + 1) as f64)) as i32) + min;\n}\n\nexport function countSetBits(n: u8): u8 {\n  let count: u8 = 0;\n  while (n) {\n    count += n & 1;\n    n >>= 1;\n  }\n  return count;\n}\n\nexport function getRegularIndexFromSideIndex(sizeX: i32, sizeY: i32, sideIndex: i32): i32 {\n  let maxSide = 2 * (sizeX + sizeY) - 4;\n\n  let startIndex: i32 = 0;\n  if (sideIndex < sizeX) {\n    startIndex = sideIndex;\n  } else if (sideIndex < maxSide - sizeX) {\n    let x = sideIndex + 1 - sizeX;\n    startIndex = (Math.floor(x / 2) as i32) * (sizeX - 2) + sideIndex;\n  } else {\n    let volume = sizeX * sizeY;\n    startIndex = volume - maxSide + sideIndex;\n  }\n\n  return startIndex;\n}\n\nexport function getRandomSide(sizeX: i32, sizeY: i32): i32 {\n  let maxSide = 2 * (sizeX + sizeY) - 4;\n  let sideIndex = randomInt(0, maxSide - 1);\n  return getRegularIndexFromSideIndex(sizeX, sizeY, sideIndex);\n}\n\nexport function getRandomSetBit(bits: u8): u8 {\n  let total = countSetBits(bits);\n  let random = randomInt(0, total - 1);\n\n  let i: u8 = 0;\n  for (let n: u8 = 0; n < 8; n++) {\n    let flag: u8 = 1 << (n as u8);\n    if (flag & bits) {\n      if (i === random) {\n        return flag;\n      }\n      i++;\n    }\n  }\n\n  return 0;\n}\n","// Ideally these would be in a Typescript definition file, but I can't get that to work\ndeclare namespace console {\n  function logi(val: i32): void;\n  function logf(val: f32): void;\n}\n\ndeclare namespace tools {\n  function time(): i32;\n}\n\nexport function logi(val: i32): void {\n  console.logi(val);\n}\n\nexport function logf(val: f32): void {\n  console.logf(val);\n}\n\nexport function getTime(): i32 {\n  return tools.time();\n}\n","import {\n  MAX_BLENGTH,\n  HEADER_SIZE,\n  allocateUnsafe,\n  reallocateUnsafe,\n  loadUnsafe,\n  storeUnsafe\n} from \"./internal/arraybuffer\";\n\nimport {\n  defaultComparator,\n  insertionSort,\n  weakHeapSort\n} from \"./internal/array\";\n\nexport class Array<T> {\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  @inline\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (!callbackfn(loadUnsafe<T,T>(buffer, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (predicate(loadUnsafe<T,T>(buffer, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? loadUnsafe<T,T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator(\"{}\")\n  private __unchecked_get(index: i32): T {\n    return loadUnsafe<T,T>(this.buffer_, index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    storeUnsafe<T,T>(buffer, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  @operator(\"{}=\")\n  private __unchecked_set(index: i32, value: T): void {\n    storeUnsafe<T,T>(this.buffer_, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return false;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return true;\n      ++fromIndex;\n    }\n    return false;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    storeUnsafe<T,T>(buffer, length, element);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var element = loadUnsafe<T,T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      callbackfn(loadUnsafe<T,T>(buffer, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var buffer = this.buffer_;\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var resultBuffer = result.buffer_;\n    for (let index = 0; index < length && index < this.length_; ++index) {\n      storeUnsafe<U,U>(resultBuffer, index, callbackfn(loadUnsafe<T,T>(buffer, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var buffer = this.buffer_;\n    var length = this.length_;\n    var result = new Array<T>();\n    for (let index = 0; index < length && index < this.length_; ++index) {\n      let value = loadUnsafe<T,T>(buffer, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      accum = callbackfn(accum, loadUnsafe<T,T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index: i32 = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, loadUnsafe<T,T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var buffer = this.buffer_;\n    var element = loadUnsafe<T,T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    storeUnsafe<T,T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (callbackfn(loadUnsafe<T,T>(buffer, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    storeUnsafe<T,T>(buffer, 0, element);\n    this.length_ = newLength;\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    if (begin < 0) begin = max(length + begin, 0);\n    else if (begin > length) begin = length;\n    if (end < 0) end = length + end; // no need to clamp\n    else if (end > length) end = length;\n    if (end < begin) end = begin;    // ^\n    var newLength = end - begin;\n    assert(newLength >= 0);\n    var sliced = new Array<T>(newLength);\n    if (newLength) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\n        <usize>newLength << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\n    if (deleteCount < 1) return;\n    var length = this.length_;\n    if (start < 0) start = max(length + start, 0);\n    if (start >= length) return;\n    deleteCount = min(deleteCount, length - start);\n    var buffer = this.buffer_;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>()),\n      changetype<usize>(buffer) + HEADER_SIZE + (<usize>(start + deleteCount) << alignof<T>()),\n      <usize>deleteCount << alignof<T>()\n    );\n    this.length_ = length - deleteCount;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = loadUnsafe<T,T>(buffer, front);\n      storeUnsafe<T,T>(buffer, front, loadUnsafe<T,T>(buffer, back));\n      storeUnsafe<T,T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = defaultComparator<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = loadUnsafe<T,T>(buffer, 1); // a = arr[1]\n      let b = loadUnsafe<T,T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        storeUnsafe<T,T>(buffer, 1, b);   // arr[1] = b;\n        storeUnsafe<T,T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n\n    if (isReference<T>()) {\n      // TODO replace this to faster stable sort (TimSort) when it implemented\n      insertionSort<T>(buffer, 0, length, comparator);\n      return this;\n    } else {\n      if (length < 256) {\n        insertionSort<T>(buffer, 0, length, comparator);\n      } else {\n        weakHeapSort<T>(buffer, 0, length, comparator);\n      }\n      return this;\n    }\n  }\n\n  private __gc(): void {\n    var buffer = this.buffer_;\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\n    if (isManaged<T>()) {\n      let offset: usize = 0;\n      let end = <usize>this.length_ << alignof<usize>();\n      while (offset < end) {\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\n        offset += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { AL_MASK, MAX_SIZE_32 } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n      memory.fill(\n        changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      memory.fill(\n        changetype<usize>(newBuffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n      return newBuffer;\n    }\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n@inline export function loadUnsafe<T,V>(buffer: ArrayBuffer, index: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline export function storeUnsafe<T,V>(buffer: ArrayBuffer, index: i32, value: V): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n\n@inline export function loadUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, byteOffset: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline export function storeUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, value: V, byteOffset: i32): void {\n  store<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n","/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n"]}